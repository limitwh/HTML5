<!DOCTYPE html>
<html lang="zh">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<title>hifve基础篇</title>
		<link href="../lib/toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css" />
		<link href="../lib/toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css" />
		<link href="../lib/toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css" />
		<link rel="stylesheet" type="text/css" href="../css/common.css"/>
	</head>

	<body>
		<div>
			<div style='width:25%;'>
				<ul id="tree" class="ztree" style='width:100%'>

				</ul>
			</div>
			<div id='readme' style='width:70%;margin-left:20%;'>
				<article class='markdown-body'>
					<h1>hifive的基本认识</h1>
					<h2>hifive的概念</h2>
					<blockquote>
						<p><strong>hifive是本社前端系统开发的一套基于下一代web标准的实装支援框架。它采用MVC的设计模式，MVC是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，
							用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。
							MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。接下来我们就开始学习hifive前端框架。</strong></p>
					</blockquote>
					<h1>hfiive的安装</h1>
					<h2>hifive的导入</h2>
					<blockquote>
						<p>我们可以从这个页面来下载hifive。 并且，为使用的人提供了源代码的托管服务（可以不用下载到本地，使用服务器上的源代码）。 如下所示，在HTML文档中首先下载读取hifive相应的CSS文件和JS文件。 但是，因为hifive是依赖于jQuery的，所以不要忘记首先应该下载读取jQuery文件。</p>
						<pre><code>&lt;!doctype html&gt;  
&lt;html&gt; 
  &lt;head&gt; 
    &lt;meta charset="UTF-8"&gt; 

    &lt;!-- hifive样式的读取 --&gt; 
    &lt;link href="//code.htmlhifive.com/h5.css" rel="stylesheet"&gt; 

    &lt;!-- jQuery的读取。IE8以下的情况下使用第一种，其他的情况下使用第二种&gt; 
    &lt;!--[if lt IE 9]&gt; 
    &lt;script src="//code.jquery.com/jquery-1.11.1.min.js"&gt; &lt;/script&gt; 
    &lt;![endif]--&gt; 
    &lt;!--[if gte IE 9]&gt; &lt;!--&gt; 
    &lt;script src="//code.jquery.com/jquery-2.1.1.min.js"&gt; &lt;/script&gt; 
    &lt;!--![endif]--&gt; 

    &lt;!-- hifive前端框架的读取--&gt; 
    &lt;script src="//code.htmlhifive.com/ejs-h5mod.js"&gt; &lt;/script&gt; 
    &lt;script src="//code.htmlhifive.com/h5.dev.js"&gt; &lt;/script&gt; 
  &lt;/head&gt;
  &lt;body&gt;
    Hello.
  &lt;/body&gt;
&lt;/html&gt;	
						</code></pre>
						<strong>※以上的例子使用了hifive源代码的在线托管服务。 hifive已经下载到本地，或者应用正式上线等时候，请将以上的各文件地址修改为本地对应的文件地址。</strong>
					</blockquote>
					<h2>运行确认</h2>
					<blockquote>
						<p>请在浏览器中打开已作成的页面（HTML文件）。 然后、打开浏览器的开发者工具（按F12）、请确认控制台下将显示如下信息：
“[INFO] hifive开发用版已读取成功。应用正式上线发布时，请使用Minify版（h5.js）。”
该日志消息不表示时，请确认如下几点：</p>
						<ul>
							<li>文件保存好了吗？</li>
							<li>JavaScript的URL是否正确？</li>
							<li>读取hifive之前，是否已导入jQuery？</li>
							<li>控制台上有出现什么错误消息吗？</li>
							<li>由于不同浏览器的设置不一样，当以文件形式打开HTML时（URL的开头为file://），会有JavaScript不读取执行的情况出现。解决方法有以下两种：浏览器设置为允许JavaScript执行，或者将文件放在HTTP服务器上，以http://的URL形式打开。（※第一种解决方案可能会出现一部分功能仍无法运行，因此推荐第二种解决方案）。</li>
						</ul>
					</blockquote>
					<h2>HelloWorld</h2>
					<blockquote>
						<p>首先，我们尝试做一个简单的应用：按下按钮，立刻弹出“Hello, World!”的对话框。
沿着以下三步，可使用hifive来实现该应用。</p>
						<ul>
							<li>首先，定义hifive MVC模型中最核心的控制器。</li>
							<li>然后，将控制器与相应的HTML元素绑定。</li>
							<li>最后，定义实现该HTML元素相应的事件响应程序。</li>
						</ul>
					</blockquote>
					<p><strong>1. 编写JS文件（比如说step3.js）</strong></p>
					<blockquote>
						<pre><code>$(function() {
    var helloWorldController = {
        __name: 'HelloWorldController',
 
        '#btn click': function() {
            alert('Hello, World!');
        }
    };

    h5.core.controller('#container', helloWorldController );
});</code></pre>
						<ul>
							<li>第2行～8行，定义了「控制器」。</li>
							<li>第3行的_name为该控制器的名称。_name属性是必须定义的，否则会出现错误。</li>
							<li>第5行～7行，定义了事件响应句柄。</li>
							<li>在hifive中，事件响应句柄的形式为：「(匹配该条件的HTML元素) (发生的事件): (事件发生时执行的函数)」。 （我们将在下一节中详细说明）</li>
							<li>第10行，控制器与HTML元素进行了绑定。在该程序中，我们将id为container的元素与控制器进行了绑定。 为了让控制器实际能运行起来，必须确保它绑定了某个元素。</li>
						</ul>
					</blockquote>
					<p><strong>2. 编写HTML文件，读取已编写好的JS文件。</strong></p>
					<blockquote>
						<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
       &lt;meta charset="UTF-8"&gt;
        &lt;script src="jquery.js"&gt;&lt;/script&gt;
        &lt;script src="ejs-1.0.h5mod.js"&gt;&lt;/script&gt;
        &lt;script src="h5.js"&gt;&lt;/script&gt;

        &lt;!-- 在这边引入js文件--&gt;
        &lt;script src="step3.js"&gt;&lt;/script&gt;
 
        &lt;title&gt;hifive Hello World&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="container"&gt;
            &lt;input type="button" id="btn" value="hello world!" /&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
					</blockquote>
					<p><strong>3. 运行确认</strong></p>
					<blockquote>
						<p>点击id=”btn”的按钮后，自动触发控制器中定义的点击事件程序，显示’Hello, World!’信息的对话框出现。</p>
					</blockquote>
					<h1>框架说明</h1>
					<blockquote>
						<p>在使用Hifive框架的过程中，我们主要采用MVC分离的形式，将功能分开，降低了代码的耦合度，更便于日后项目的运行和维护。通常在使用Hifive框架来写js代码的时候
						将代码按照功能的不同，分别放在不同的文件中。例如，我们将描述某个事物属性的代码放到Model模型中。将一些数据请求、运算和逻辑的代码放到Logic中。最后将对页面上文档的操作
						放到Controller控制器中。接下来，根据每一个部分代码的特点详细的介绍一下用法。
						</p>
					</blockquote>
					<h1>框架构成</h1>
					<h2>Controller(控制器)</h2>
					<h3>概要</h3>
					<blockquote>
						<p>控制器是与用户交互处理的中心，具体表现为：</p>
						<ul>
							<li>事件绑定</li>
							<li>使用Logic、View（模板）声明</li>
							<li>定义了生命周期事件</li>
							<li>DOM操作</li>
						</ul>
						<p>在这里，我们创建了下面的项目，来说明控制器的编写方法。</p>
					</blockquote>
					<h3>控制器化</h3>
					<blockquote>
						<p>在详细说明控制器之前，先解释一下「控制器化」这个词语。
如教程02.HelloWorld所示，调用hifive中的h5.core.controller()方法，将定义成控制器的对象与元素绑定，并使之处于可运行状态。
此时在控制器与元素绑定之前,内部进行了</p>
						<ul>
							<li>基于被定义为控制器的对象，生成实例（克隆）。</li>
							<li>实例中默认自动生成可使用的一系列常用的函数。</li>
							<li>设置事件句柄</li>
						</ul>
						<p>等等处理，被称为「控制器化」。
在学习的现阶段，把「控制器化」理解为 「调用h5.core.controller()方法，并使之处于可运行状态」。</p>
					</blockquote>
					<h3>事件句柄</h3>
					<blockquote>
						<p>由于发生的某事件而被调用的函数被称为事件句柄。
事件大多数是由用户通过点击鼠标、键盘输入等操作所产生的。
事件处理（事件绑定）是控制器所控制的最基本的处理。
hifive的控制器中，通过特定的写法定义属性，不仅可以自动将其识别为事件句柄，而且在发生按钮点击等事件时也能自动调用该函数。</p>
					</blockquote>
					<p><strong>基本结构</strong></p>
					<p>一起来制作一个控制器，控制一个id为btn的元素，当点击它时（click事件发生时）触发处理程序。</p>
					<pre><code>var sampleController = {  
  __name: 'SampleController',  
   
  '#btn click': function(context, $el) {  
    alert('按钮已被点击');  
  }  
};</code></pre>
					<p>第二行的__name属性为控制器名称（__name属性是必须定义的属性，否则会发生错误）。
在这里所指定的值相当于Java或者C#、Ruby等语言中的类名
在hifive框架中，原则上与之同名的被当做同一事物（类）所看待。
因此，请务必为每个控制器定义不同的名字。若使用了已被定义绑定了的名字，程序可能会出现不正确的行为。
实际开发中、
__name属性开头还将添加有该包的全名。
因此，请务必为每个控制器定义不同的名字。若使用了已被定义绑定了的名字，程序可能会出现不正确的行为。</p>
					<p><strong>定义句柄</strong></p>
					<p>第4行定义了事件句柄。该事件句柄结构如下：</p>
					<pre><code>'(选择器) (事件名)': function(context, $el) {  
   // 处理
 }  </code></pre>
 					<p>我们可以这样理解：</p>
 					<pre><code>'(匹配这个选择器的元素) (这个事件一触发)': funciton(){}//(执行这个函数)</code></pre>
					<p>事件名，不仅仅是click或submit等既定事件，而且也能指定为自定义事件。</p>
					<p><strong>调用方法</strong></p>
					<p>控制器定义结束后，将对元素进行绑定。绑定时，请调用方法h5.core.controller()。</p>
					<pre><code>h5.core.controller(selector, controller, param); </code></pre>
					<ul class="space">
						<li>selector
							<ul>
								<li>选择器绑定。可指定为选择器或是元素的参照物。</li>
							</ul>
						</li>
						<li>controller
							<ul>
								<li>指定了选择器定义的对象。</li>
							</ul>
						</li>
						<li>param
							<ul>
								<li>向控制器所传递的初期参数。</li>
							</ul>
						</li>
						<li>Returns
							<ul>
								<li>返回控制器对象。</li>
							</ul>
						</li>
					</ul>
					<h3>事件句柄参数</h3>
					
					<p><strong>第一参数:事件上下文</strong></p>
					<p>事件句柄的第1参数：事件上下文对象。
虽然形参可以定义为任意名字，但是无特殊理由还是统一定义为「context」。 事件上下文对象包含的属性如下：</p>
					<ul class="space">
						<li>event
							<ul>
								<li>jQueryEvent对象</li>
							</ul>
						</li>
						<li>controller
							<ul>
								<li>控制器</li>
							</ul>
						</li>
						<li>evArg
							<ul>
								<li>使用trigger方法所传递的参数</li>
							</ul>
						</li>
					</ul>
					<p><strong>第二参数：事件的目标元素</strong></p>
					<p>第2个参数是版本ver.1.1.4中追加的，在此之前不传递第2个参数。
现在，第2个参数是发生该事件的目标元素。虽然形参可以定义为任意的名字，但是无特殊理由统一定义为「$el」（"el"是element的简称）。也就是说，是将事件句柄中选择器所指定的元素包装为jQuery对象，然后进行传递的参数。若直接为该元素设置事件句柄，句柄中调用的”this”指向元素本身。</p>
					<pre><code>&lt;ul class="list"&gt;
  &lt;li class="listItem"&gt;listItem&lt;/li&gt;  &lt;!-- 点击这个元素 --&gt;
&lt;/ul&gt;</code></pre>
					<pre><code>var listController = {
  __name: 'ListController',

  '.listItem click': function(context, $el) {
      //$el是当前选中的那个li元素
  }
}
h5.core.controller('.list', listController);</code></pre>
					<pre><code>h5.settings.listenerElementType = 0;</code></pre>
					<p>虽然传递的$el默认为jQuery对象，但是也可以传递原生元素，不对其进行jQuery包装。想要传递原生对象时，请在读取h5.js文件后编写如下代码。</p>
					<pre><code>h5.settings.listenerElementType = 0;</code></pre>
					<p>注意：事件冒泡 
如上所示，$el指定为「发生该事件的元素（由选择器指定）」。 但当选择器指定的元素包含了子元素，子元素上发生事件时，「事件发生的根元素」和$el是不同的。</p>
					<pre><code>&lt;div id="container"&gt;  &lt;!-- 把控制器器绑定在这个元素上 --&gt;
    &lt;div class="parent"&gt; 
        &lt;a class="target" href="#"&gt;LINK&lt;/a&gt;  &lt;!-- 点击这个元素 --&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
					<pre><code>var sampleController = {
  __name: 'SampleController',

  '.parent click': function(context, $el) {
     //即使是点击a标签的情况下，因为指定的选择器还是父元素div元素。
     //$el（指定的父元素）为指定的div元素
     //想要知道事件的发生元素的话，可以通过使用$(context.event.target)记录。
  },

  '.target click': function(context, $el) {
     //指定a标签（指定的选择器）的处理程序
     //那么$el当然指定为a标签。
  }
};
h5.core.controller('#container', sampleController);</code></pre>
					<h3>事件句柄的有效范围</h3>
					<p>控制器中定义的事件句柄，原则上，只有在「该控制器绑定元素的子元素上事件发生时」才运行。这样一来，在明确了控制器的责任范围的同时，也可以防止一些不正确的行为，例如：选择器条件范围很大的时候，若控制器范围外的元素上有事件发生，也不会启动该事件处理程序。</p>
					<p><strong>HTML:</strong></p>
					<pre><code>&lt;body&gt;  
  &lt;div id="container"&gt;  
    &lt;input type="button" name="click1" value="click1" /&gt;  
  &lt;/div&gt;  
  &lt;div&gt;  
    &lt;input type="button" name="click2" value="click2" /&gt;  
  &lt;/div&gt;  
&lt;/body&gt;  </code></pre>
					<p><strong>JavaScript:</strong></p>
					<pre><code>var selectorController = {  
  __name: 'SelectorController',  
   
  'input[type=button] click': function(context, $el) {  
    alert('clicked!');  
  }  
};  
h5.core.controller('#container', selectorController);  </code></pre>
					<p>比如上面的例子，因为selectorController绑定的元素是id="container"，因为按下click1按钮时（click1是id="container" 的子元素）会弹出消息，而按下click2按钮时什么也不会发生。
但是，也会有一些例外，想要把控制器范围外的元素也作为处理对象。
想要将画面上所有的元素（控制器外、或者是包含的同级元素）作为选择器的对象时，只需要在选择器外加上中括弧就OK了。</p>
					<pre><code>var selectorController = {  
  __name: 'SelectorController',  
   
  'input[type=button] click': function(context, $el) { 
    alert('clicked!');  
  }  
};</code></pre>
					<p>如果控制器定义为这样，按下任意按钮，都有会消息弹出。 还有就是，不能将选择器指定为控制器本身所绑定的元素。 如果想要为元素本身设置事件句柄时，选择器需要替换为{rootElement}。</p>
					<pre><code>var selectorController = {  
  __name: 'SelectorController',  
   
  '{rootElement} click': function(context, $el) {  //{rootElement}指代绑定控制器的元素本身  
    alert('clicked!');  
  }  
}; </code></pre>
					<h3>控制器的声明周期</h3>
					<p>控制器在绑定元素到正常运作的状态是需要经过几个阶段的（生命周期）。
控制器的生命周期如下所示：</p>
					<img src="../images/lifecycle1.jpg"/>
					<p>想要处理程序在生命周期的特定阶段运行时，只需在相应的关键字下设置处理函数即可，到了相应的时间段函数会自动调用运行。</p>
					<ul class="space">
						<li>__construct
							<ul>
								<li>控制器化结束阶段运行。资源（视图模板）的读取尚未结束。</li>
							</ul>
						</li>
						<li>__init
							<ul>
								<li>控制器化和必要的资源读取后，在视图绑定结束阶段运行。此时，事件句柄尚未绑定。</li>
							</ul>
						</li>
						<li>
							__postInit
							<ul>
								<li>在控制器化的__init阶段结束后运行。在这个阶段关于控制器的模板的引入，rootElement的设置以及rootController和parentController的设置全部结束。</li>
							</ul>
						</li>
						<li>__ready
							<ul>
								<li>控制器化和必要的资源读取，以及视图绑定结束后的阶段运行。 控制器化可运行状态下想要让程序再做点什么时，几乎都是使用__ready。</li>
							</ul>
						</li>
					</ul>
					<p>在理解了控制器生命周期各阶段的定义和作用后，按照该规范编写，可以使得源代码更加自然和易于理解，并且作用域更加明确。</p>
					<h2>View（视图）</h2>
					<h3>概要</h3>
					<blockquote>
						<p>JavaScript可以从程序处理的任何地方对视图进行操作（画面操作，也称为DOM操作）。 但是，这种具有很强灵活性的反面在于，很难理解程序的什么部分对应了什么操作，在进行维护的阶段，画面的些许变动都变得十分困难。
而在hifive中规定了：原则上，视图的操作只能在控制器中进行。 遵守了此规定，我们将十分清楚视图操作一定是在控制器中进行的。因此，在别人接手管理和维护程序时，很容易地就知道从何处入手。
除此之外，为生成视图，hifive还引入了EJS这样的模板引擎。 通过利用模板引擎，对拥有复杂构造的标签，可以从视觉上进行编写。代码的可维护性和可读性也会大大增强。</p>
					</blockquote>
					<h3>元素的操作</h3>
					<blockquote>
						<p>读取标签input的value值、在标签div中插入文字等单个元素的读写操作使用到了jQuery。
但是，在选择DOM元素时，请使用控制器中的this.$find()方法，而不要直接使用jQuery中的$()方法。
此方法只会在绑定的元素下去检索要选择的元素，因此可以防止对控制器范围外元素的误操作。
想要对控制器绑定元素自身进行操作的时候怎么做？
控制器中包含了一个叫rootElement的实例，使用该实例可以对绑定的元素本身进行操作。 使用$(this.rootElement)方法，绑定的元素本身可以使用各种jQuery的方法操作。</p>
					</blockquote>
					<p><strong>操作方法</strong></p>
					<p>※因为this.$find()方法的值为jQuery对象（选择器所指定的元素），所以可以对该值进行各种jQuery的方法操作。</p>
					<table>
						<tr>
							<th>操作内容</th>
							<th>实装方法</th>
						</tr>
						<tr>
							<td>元素生成</td>
							<td><code>$(标签)</code></td>
						</tr>
						<tr>
							<td>元素选择</td>
							<td><code>this.$find(选择器)</code></td>
						</tr>
						<tr>
							<td>元素删除</td>
							<td><code>this.$find(选择器).remove</code></td>
						</tr>
						<tr>
							<td>要素内容的更新</td>
							<td><pre><code>this.$find(选择器).html(element);
this.$find(选择器).text(value);
this.$find(选择器).val(value);</code></pre></td>
						</tr>
					</table>
					<p><strong>※this指向controller本身。</strong></p>
					<h3>生成模板</h3>
					<p><strong>基本结构</strong></p>
					<p>作成由多个标签所构成的复杂视图时，可以使用视图模板。
一个模板被记录在一个&lt;script&gt; type="text/ejs"&gt;&lt;/script&gt;标签中。
每个模板都拥有唯一的ID（设置&lt;script&gt;标签中的id属性）</p>
					<p>EJS的语法和JSP非常地相似。
JavaScript代码的开始为[%，结束为%]。
[% %]可以写在任何的地方。</p>
					<pre><code>&lt;script type="text/ejs" id="list"&gt;
  [% for (var i = 1, len = num + 1; i < len; i++) { %]
    &lt;li&gt;
      &lt;span style="[%= 'color: ' + (i % 2 === 0 ? 'blue;': 'red;') %]"&gt;[%= i %]&lt;/span&gt;
    &lt;/li&gt;
  [% } %]
&lt;/script&gt;</code></pre>
					<p><strong>模板定义位置</strong></p>
					<p>模板可以在下面两处进行定义。</p>
					<ul class="space">
						<li>1.在单独的文件中进行描述</li>
						<li>2.在HTML中直接描述</li>
					</ul>
					<p>一般来说推荐使用单独文件来进行描述，
但是下面两种情况更适合在HTML中直接进行定义：</p>
					<ul class="space">
						<li>1.该模板只在特定的画面中使用</li>
						<li>2.希望将HTTP请求数最小化</li>
					</ul>
					<p>若是单独文件会发出新的HTTP请求。
把模板定义在单独文件中时，推荐文件后缀名使用.ejs</p>
					<p><strong>模板文件的读取</strong></p>
					<p>如果模板定义为外部文件，可以使用控制器的_templates属性，只用预先写好模板文件的URL地址，控制器化开始时会自动读取模板。 因为控制器化是在指定模板文件读取后才实际运行的，所以模板中元素绑定的事件句柄等处理也能运行的。
如果是直接写在HTML中，那么任何时候都可以使用。 （不用写_templates属性）</p>
					<p><strong>语法检查的使用</strong></p>
					<p>在下载读取有错误的模板代码时，通常无法知道是在模板的什么位置发生了错误。
为此，这里也提供了输出错误信息内容和发生行数的类库。</p>
					<p>可以从下面的地址下载：</p>
					<a href="http://embeddedjavascript.googlecode.com/files/ejs_fulljslint.js">http://embeddedjavascript.googlecode.com/files/ejs_fulljslint.js</a>
					<p><strong>模板操作</strong></p>
					<p>使用模板并将其显示到画面时，可以使用控制器中this.view对象的以下方法。<br />
※this指向该控制器本身。<br />
（以下方法只能在控制器中使用。）</p>
					<table>
						<tr>
							<th>方法名</th>
							<th>说明</th>
						</tr>
						<tr>
							<td>update(对象要素指定的选择器, 模板ID, 置换参数)</td>
							<td>对象要素的中间，更新指定的模板</td>
						</tr>
						<tr>
							<td>append(对象要素指定的选择器, 模板ID, 置换参数)</td>
							<td>对象要素的最后，插入指定的模板</td>
						</tr>
						<tr>
							<td>prepend(对象要素指定的选择器, 模板ID, 置换参数)</td>
							<td>对象要素的最前面，插入指定的模板</td>
						</tr>
					</table>
					<p>不直接将其显示到画面，而是想要取得该模板下的标签文本（代码）时，
请使用this.view.get(模板ID, 置换参数)方法。</p>
					<p><strong>案例</strong></p>
					<p><strong>1.编写HTML</strong></p>
					<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;script src="jquery.js"&gt;&lt;/script&gt;
     &lt;script src="ejs-1.0.h5mod.js"&gt;&lt;/script&gt;
    &lt;script src="h5.js"&gt;&lt;/script&gt;
    &lt;!-- 在这边引入js文件 --&gt;
    &lt;script src="step5.js"&gt;&lt;/script&gt;
     &lt;title&gt;hifive 视图操作&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="container"&gt;
      &lt;div&gt;
        从1到输入的数值中为奇数的是&lt;span style="color: red;"&gt;红色&lt;/span&gt;で、
        偶数是&lt;span style="color: blue;"&gt;蓝色&lt;/span&gt;的画面。
      &lt;/div&gt;
      &lt;input type="text" id="to" value="" /&gt;
      &lt;input type="button" id="output" value="出力" /&gt;
      &lt;ul id="list"&gt;&lt;/ul&gt; &lt;!-- 这边在页面渲染出模板 --&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
					<p><strong>2.编写list.ejs文件</strong></p>
					<pre><code>&lt;script type="text/ejs" id="list"&gt;
[% for (var i = 1, len = num + 1; i < len; i++) { %]
&lt;li&gt;
  &lt;span style="[%= 'color: ' + (i % 2 === 0 ? 'blue;': 'red;') %]">[%= i %]&lt;/span&gt;
&lt;/li&gt;
[% } %]
&lt;/script&gt;</code></pre>
					<p><strong>※[script]标签所指定的List是调用this.view.get()方法时必须的模板ID。</strong></p>
					<p><strong>3.编写step5.js文件。</strong></p>
					<pre><code>$(function() {
  // 首先定义一个controller对象
  var controller = {

  // 设定controller名
  __name: 'NumListController',

  // 引入使用的模板路径
  __templates: 'list.ejs',  //要引入多个ejs文件的时候，请指定数组形式。

  // 点击id=output时的事件处理程序
  '#output click': function() {
    // 获取到用户输入的值
    var to = this.$find('#to').val();
    //处理如果没有值得情况
    if (!to) {
      return;
    }
    //将字符串类型转变为数字类型，如果转换失败的话就结束
    try {
      to = parseInt(to);
    } catch(e) {
      return;
    }

    //根据数据将绑定的模板在画面上输出
      this.view.append('#list', 'list', {
        num: to
      });
    }
  };

  //将控制器绑定在id为container的元素上
  h5.core.controller('#container', controller);
});</code></pre>
					<p><strong>4.在浏览器中打开HTML。</strong></p>
					<p><strong>5.在文本框里输入数字，然后点击输出按钮。</strong></p>
					<p><strong>向模板传递值</strong></p>
					<p>hifive所提供的模板与JSP一样，可以在模板中的任意地方使用[% %]或者[%= %]设置任何值。[% %]中的文本会被自动转义为HTML，[%:= %]不会被转义。 <br />
向模板传值时，如以下方法指定：<br />
{模板要使用的变量名：变量的值}。</p>
					<p><strong>使用例(1)</strong></p>
					<pre><code>this.view.append('#container', 'templateId1', {ar: [10, 20, 30]});</code></pre>
					<p><strong>使用例(2)</strong></p>
					<p>多个值进行传递的方法，于传递对象语法相同， <br />
{模板使用的变量名: 变量值, 模板使用的变量名: 变量值, ...} <br />
像上面一样用逗号进行分隔指定。</p>
					<pre><code>this.view.append('#container', 'templateId1', {ar: [10, 20, 30], str:'Hello World!'});</code></pre>
					<p>在例子中，step5.js的第27行</p>
					<pre><code>this.view.append('#list', 'list', {num: to});</code></pre>
					<p>其中的第3个参数{num: to}作为值传递给模板，该值在list.ejs的第2行</p>
					<pre><code> [% for (var i = 1, len = num + 1; i < len; i++) { %]</code></pre>
					<p>中被num使用。
像这样，通过将对象名和模板使用的变量名指定为相同的名字，然后再使用view.get()、view.append()、view.update()、 view.prepend()等方法，可以进行值的传递。</p>
					<p><strong>模板的复写</strong></p>
					<p>定义外部文件和在HTML中直接定义两者，都可以定义多个模板。但是，请把模板id设为不同。
当多个模板的ID相同，在读取模板的情况下，程序将如何运作
模板id重复的时候，后读取的模板将会被读取（覆盖了前者）。
不想被覆盖时，请给模板文件设置唯一的id。
ejs文件读取的优先顺序如下：</p>
					<ul class="space">
						<li>1.因为ejs文件是由上到下顺序读取的，所以文件中后定义的优先。</li>
						<li>2.控制器中_templates属性定义了多个ejs文件时，数组最后中指定的ejs文件优先</li>
					</ul>
					<p>如以下代码中的例子，运行时将输出hello 2。</p>
					<p><strong>view.ejs</strong></p>
					<pre><code>&lt;script type="text/ejs" id="list"&gt;
  hello 1
&lt;/script&gt;
&lt;script type="text/ejs" id="list"&gt;
  hello 2
&lt;/script&gt;</code></pre>
					<p><strong>test.js</strong></p>
					<pre><code>var testController = {
  __name: 'TestController',
  __templates: 'view.ejs',
  __ready: function() {
    alert(this.view.get('list'));
  }
}

h5.core.controller('body', testController);</code></pre>
					<p><strong>test.html</strong></p>
					<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;script src="jquery.js"&gt;&lt;/script&gt;
    &lt;script src="jquery.blockUI.js"&gt;&lt;/script&gt;
    &lt;script src="ejs-1.0.h5mod.js"&gt;&lt;/script&gt;
    &lt;script src="h5.js"&gt;&lt;/script&gt;
    &lt;script src="test.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html></code></pre>
					<h3>视图操作的注意事项</h3>
					<p><strong>在画面中，请为每个元素设置唯一的id</strong></p>
					<p>这个是HTML的标准。</p>
					<ul class="space">
						<li>1.如有像列表行等多次出现画面的情形，应该使用CSS类名而不是id来区分命名，或者添加唯一的data-*属性来区分等方法。</li>
						<li>2.需要特别地注意通过Ajax动态刷新画面的地方。</li>
						<li> 3.如果现在有多个元素有着相同的id，并且使用this.$find('#id')或document.getElementById('id')等方法来获取元素时，在大多数的浏览器下页面会取得最初所定义的那个元素。但是，由于动作是依赖于处理引擎的，因此相同的代码运行结果不一定相同。</li>
					</ul>
					<h2>Logic(逻辑层)</h2>
					<h3>概要</h3>
					<p>在hifive中，「逻辑」被定义为诸如：</p>
					<ul class="space">
						<li>1.复杂的计算</li>
						<li>2.与服务器的通信</li>
						<li>3.本地DB操作</li>
					</ul>
					<p>等只是进行纯粹的（不包含画面操作）通信和计算的东西。
通过整理和归纳这些「处理」、程序的可读性、可维护性、重用性和易测试性大大增强。
并且，通过使用下一节介绍的异步处理功能，能使得逻辑内部实现的变更不会影响到整个处理。</p>
					<h3>逻辑的定义</h3>
					<p>逻辑的定义如下：</p>
					<p><strong>1. 定义了程序的逻辑部分</strong></p>
					<pre><code>var dateLogic = {  
   
  __name: 'DateLogic',  
   
  dateFormat: '{0}年{1}月{2}日',  
   
  getCurrent: function(time) {  
    var year = time.getYear();  
    var month = time.getMonth() + 1;  
    var date = time.getDate();  
    return this._format(year, month, date);  
  },  
   
  _format: function(year, month, date) {
    return h5.u.str.format(this.dateFormat, year, month, date);
  }
};</code></pre>
					<ul class="space">
						<li><strong>__name</strong>
							<ul>
								<li>定义了该逻辑程序的名称。与控制器名相同，是必须要定义的属性。未定义时，会发生错误。</li>
							</ul>
						</li>
						<li><strong>publicMethod</strong> 
							<ul>
								<li>公共方法的名称开头禁用”_”</li>
							</ul>
						</li>
						<li><strong>privateMethod</strong> 
							<ul>
								<li>私有方法的名称开头请使用”_”</li>
							</ul>
						</li>
					</ul>
					<p><strong>2.请在控制器中声明</strong></p>
					<pre><code>var dateController = {  
  __name: 'DateController',  
   
  dateLogic: dateLogic,  
   
  __ready: function(context) {  
    var current = this.dateLogic.getCurrent(new Date());  
    alert(current);  
  }  
};</code></pre>
					<p>请声明要在该控制器中使用的逻辑。后缀一定要为Logic。
声明的逻辑通过框架会被自动“逻辑化”，成为hifive中的逻辑对象。</p>
					<h3>实例</h3>
					<p><strong>1. 编写HTML</strong></p>
					<pre><code>&lt;!doctype html&gt;
&lt;html&gt;  
    &lt;head&gt;  
        &lt;meta charset="UTF-8"&gt;  
        &lt;script src="jquery.js"&gt;&lt;/script&gt;  
        &lt;script src="jquery.blockUI.js"&gt;&lt;/script&gt;  
   
        &lt;script src="ejs-1.0.h5mod.js"&gt;&lt;/script&gt;  
        &lt;script src="h5.js"&gt;&lt;/script&gt;  
        &lt;!-- 在这边引入js文件 --&gt;  
        &lt;script src="step6.js"&gt;&lt;/script&gt;  
   
        &lt;title&gt;hifive Step6&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
        &lt;div id="container"&gt;  
            &lt;input type="text" id="left" value="" /&gt; +  
            &lt;input type="text" id="right" value="" /&gt;  
            &lt;input type="button" id="calc" value="=" /&gt;  
            &lt;span id="result"&gt; &lt;/span&gt;  
        &lt;/div&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  </code></pre>
					<p><strong>2. 编写step6.js文件。</strong></p>
					<pre><code>$(function() {  
    // 定义逻辑对象  
    calcLogic = {  
        __name: 'CalcLogic',  
   
        add: function(left, right) {  
            return left + right;  
        }  
    };  
   
    // 首先定义控制器对象
    var controller = {  
        // 控制器名  
        __name: 'CalcController',  
        // 定义逻辑 
        calcLogic: calcLogic,  
            
        '#calc click': function() {  
            //获取到左边的值 
            var left = this.$find('#left').val();  

            // 从字符串类型转换为数字类型，如果转换失败的话结束操作
            left = parseInt(left);
            if (isNaN(left)) {
                return;
            } 
            // 获取到右边的值
            var right = this.$find('#right').val();  
            
            // 从字符串类型转换为数字类型，如果转换失败的话结束操作
            right = parseInt(right);
            if (isNaN(right)) {
                return;
            } 

            // 给逻辑添加add方法  
            var ret = this.calcLogic.add(left, right);  
                
            // 把结果展示在画面上
            this.$find('#result').html(ret);  
        }  
    };  
    
    //将控制器绑定在id="container"的元素上
    h5.core.controller('#container', controller);  
});  </code></pre>
					<p><strong>3. 在浏览器中打开HTML。</strong></p>
					<p><strong>4. 在左边和右边输入数字，然后点击按钮。</strong></p>
					<h3>常见问题</h3>			
					<p><strong>为什么在逻辑中不能进行画面操作？</strong></p>
					<blockquote>
						<p>在逻辑中进行的处理，也就是通信和计算，如果与画面更新处理混在一起的话，当想要改变视图（标签）构造、稍微修改下样式的时候，我们就不得不去阅读和理解这一部分的JavaScript代码。
相反，处理程序的改变也导致混入了画面操作，程序的可维护性变得非常差。
再者，由jQuery等生成的复杂标签结构最终将变成什么样，也会变得十分的难以理解，这也是可维护性下降的原因。
因此，
    虽然刚开始写的时候会有些麻烦
    虽然从设计的角度说在逻辑内可以对视图进行操作
但是，还是强烈推荐遵循hifive框架代码的规则，将逻辑与画面操作分离开来。
并且，为了让视图操作变得更加轻松，hifive也提供了模板引擎。</p>
					</blockquote>
					
				</article>
								<!--返回首页按钮-->
			<input class="btn" type="button" name="" id="" value="返回首页" />
			<!--跳转到下一章节-->
			<input class="btn1" type="button" name="" id="" value="下一章节" />
			<!-- 返回顶部按钮 -->
			<div class="backTop"></div>
			</div>
		</div>
	</body>

</html>
<script type="text/javascript" src="../lib/toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="../lib/toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="../lib/toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="../lib/toc_conf.js"></script>
<script type="text/javascript" src="../js/common.js"></script>
<script>
	$('.btn1').click(function(){
		location.href='./exercise7.html'
	})
</script>