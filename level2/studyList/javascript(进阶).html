<html>

	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<title>javascript(进阶)</title>
		<link href="../lib/toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css" />
		<link href="../lib/toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css" />
		<link href="../lib/toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css" />
		<link rel="stylesheet" type="text/css" href="../css/common.css" />
	</head>

	<body>
		<div>
			<div  style='width:25%;'>
				<ul id="tree" class="ztree" style='width:100%'>
				</ul>
				
			</div>
			<div id='readme' style='width:70%;margin-left:20%;'>
				<article class='markdown-body'>
					
					<h1 id="-">JavaScript内置对象</h1>
<blockquote>
<p>JS内置对象就是指Javascript自带的一些对象，供开发者使用，这些对象提供了一些常用的的功能。</p>
<p>常见的内置对象有Math、String、Array、Date等</p>
</blockquote>
<p>内置对象有很多，我们主要是记下这些内置对象的用法即可。我们也不可能一下子记住这么多的方法，当忘了某个方法该如何使用的时候，可以通过以下方式查看。</p>
<ul>
<li>跳转到定义<code>ctrl+左键</code></li>
<li><a href="https://developer.mozilla.org/zh-CN/">火狐开发者网站MDN</a></li>
<li><a href="http://www.w3school.com.cn/jsref/">W3School网站</a></li>
<li>离线文档</li>
</ul>
<h2 id="math-">Math对象</h2>
<blockquote>
<p>Math对象中封装很多与数学相关的属性和方法。</p>
</blockquote>
<ul>
<li><p>属性PI</p>
<p><code>Math.PI</code></p>
</li>
<li><p>最大值/最小值</p>
<pre><code>Math.max();
Math.min();
</code></pre></li>
<li><p>取整</p>
<pre><code class="lang-javascript">Math.ceil();//天花板，向上取整
Math.floor();//地板，向下取整
Math.round();//四舍五入，如果是.5，则取更大的那个数
</code></pre>
</li>
<li><p>随机数</p>
<pre><code class="lang-javascript">Math.random();//返回一个[0,1)之间的数，能取到0，取不到1
</code></pre>
</li>
<li><p>绝对值</p>
<pre><code class="lang-javascript">Math.abs();//求绝对值
</code></pre>
</li>
<li><p>次幂和平方</p>
<pre><code class="lang-javascript">Math.pow(num, power);//求num的power次方
Math.sqrt(num);//对num开平方
</code></pre>
</li>
</ul>
<h2 id="date-">Date对象</h2>
<blockquote>
<p>Date对象用来处理日期和时间</p>
</blockquote>
<ul>
<li><p>创建一个日期对象</p>
<pre><code class="lang-javascript">var date = new Date();//使用构造函数创建一个当前时间的对象
var date = new Date(&quot;2017-03-22&quot;);//创建一个指定时间的日期对象
var date = new Date(&quot;2017-03-22 00:52:34&quot;);//创建一个指定时间的日期对象
</code></pre>
</li>
<li><p>日期格式化(了解)</p>
<pre><code class="lang-javascript">date.toString();//默认的日期格式
date.toLocalString();//本地风格的日期格式（兼容性）
date.toDateString();
date.toLocalDateString();
date.toTimeString();
date.toLocalTimeString();
</code></pre>
</li>
<li><p>获取日期的指定部分</p>
<pre><code class="lang-javascript">getMilliseconds();//获取毫秒值
getSeconds();//获取秒
getMinutes();//获取分钟
getHours();//获取小时
getDay();//获取星期，0-6    0：星期天
getDate();//获取日，即当月的第几天
getMonth();//返回月份，注意从0开始计算，这个地方坑爹，0-11
getFullYear();//返回4位的年份  如 2016
</code></pre>
</li>
<li><p>时间戳</p>
<pre><code class="lang-javascript">var date = +new Date();//1970年01月01日00时00分00秒起至现在的总毫秒数
</code></pre>
</li>
</ul>
<h2 id="array-">Array对象</h2>
<blockquote>
<p>数组对象在javascript中非常的常用</p>
</blockquote>
<ul>
<li><p>数组转换</p>
<pre><code class="lang-javascript">//语法：array.join(separator)
//作用：将数组的值拼接成字符串

var arr = [1,2,3,4,5];
arr.join();//不传参数，默认按【,】进行拼接
arr.join(&quot;-&quot;);//按【-】进行拼接
</code></pre>
</li>
<li><p>数组的增删操作</p>
<pre><code class="lang-javascript">array.push();//从后面添加元素，返回新数组的length
array.pop();//从数组的后面删除元素，返回删除的那个元素
array.unshift();//从数组的前面的添加元素，返回新数组的长度
array.shift();//从数组的最前面删除元素，返回删除的那个元素

//练习1
var arr = [&quot;刘备&quot;];
//添加数据后变成：[&quot;赵云&quot;,&quot;马超&quot;,&quot;刘备&quot;,&quot;关羽&quot;,&quot;张飞&quot;]
//删除数据后变成：[&quot;关羽&quot;,&quot;张飞&quot;]

//练习2
var arr = [&quot;赵云&quot;,&quot;马超&quot;,&quot;刘备&quot;,&quot;关羽&quot;,&quot;张飞&quot;];
//把数组的最后一个元素变成数组的第一个元素
//把数组的第一个元素变成数组的最后一个元素
</code></pre>
</li>
<li><p>数组的翻转与排序</p>
<pre><code class="lang-javascript">array.reverse();//翻转数组
array.sort();//数组的排序，默认按照字母顺序排序

//sort方法可以传递一个函数作为参数，这个参数用来控制数组如何进行排序
arr.sort(function(a, b){
  //如果返回值&gt;0,则交换位置
  return a - b;
});
</code></pre>
</li>
</ul>
<pre><code>
+ 数组的拼接与截取

  ```javascript
  //concat：数组合并，不会影响原来的数组，会返回一个新数组。
  var newArray = array.concat(array2);

  //slice:数组切分，复制数组的一部分到一个新数组，并返回这个数组
  //原来的数组不受影响，包含begin，不包含end
  var newArray = array.slice(begin, end);

  //splice:数组拼接，以新元素来替换旧元素，以此来修改数组的内容，常用语删除数组的某些项
  //start:开始位置  deleteCount:删除的个数  items:替换的内容
  array.slice(start, deleteCount, [items]);
</code></pre><ul>
<li><p>数组查找元素</p>
<pre><code class="lang-javascript">//indexOf方法用来查找数组中某个元素第一次出现的位置，如果找不到，返回-1
array.indexOf(search, [fromIndex]);

//astIndexOf()从后面开始查找数组中元素出现位置,如果找不到，返回-1
array.lastIndexOf(search, [fromIndex]);
</code></pre>
</li>
<li><p>清空数组</p>
<pre><code class="lang-javascript">//1．    array.splice(0,array.leng);//删除数组中所有的元素
//2．    array.length = 0;//直接修改数组的长度
//3．    array = [];//将数组赋值为一个空数组，推荐
</code></pre>
<p>​</p>
</li>
<li><p>数组综合练习</p>
<pre><code class="lang-javascript">var arr = [&quot;c&quot;, &quot;a&quot;, &quot;z&quot;, &quot;a&quot;, &quot;x&quot;, &quot;a&quot;, &quot;a&quot;, &quot;z&quot;, &quot;c&quot;, &quot;x&quot;, &quot;a&quot;, &quot;x&quot;]
//1. 找到数组中第一个a出现的位置
//2. 找到数组中最后一个a出现的位置
//3. 找到数组中每一个a出现的位置
//4. 数组去重，返回一个新数组
//5. 获取数组中每个元素出现的次数
</code></pre>
</li>
</ul>
<h2 id="string-">String对象</h2>
<blockquote>
<p>字符串可以看成是一个字符数组。因此字符串也有长度，也可以进行遍历。String对象很多方法的名字和和Array的一样。可以少记很多的单词。</p>
</blockquote>
<ul>
<li><p>查找指定字符串</p>
<pre><code class="lang-javascript">//indexOf:获取某个字符串第一次出现的位置，如果没有，返回-1
//lastIndexOf:从后面开始查找第一次出现的位置。如果没有，返回-1
</code></pre>
</li>
<li><p>去除空白</p>
<pre><code class="lang-javascript">trim();//去除字符串两边的空格，内部空格不会去除
</code></pre>
</li>
<li><p>大小写转换</p>
</li>
</ul>
<pre><code>  toUpperCase：全部转换成大写字母
  toLowerCase：全部转换成小写字母
</code></pre><ul>
<li><p>字符串拼接与截取</p>
<pre><code class="lang-javascript">//字符串拼接
//可以用concat，用法与数组一样，但是字符串拼串我们一般都用+

//字符串截取的方法有很多，记得越多，越混乱，因此就记好用的就行
//slice ：从start开始，end结束，并且取不到end。
//subString ：从start开始，end结束，并且取不到end
// substr ： ：从start开始，截取length个字符。(推荐)
</code></pre>
</li>
<li><p>字符串切割</p>
<pre><code class="lang-javascript">//split:将字符串分割成数组（很常用）
//功能和数组的join正好相反。
var str = &quot;张三,李四,王五&quot;;
var arr = str.split(&quot;,&quot;);
</code></pre>
</li>
<li><p>字符串替换</p>
<pre><code class="lang-javascript">replace(searchValue, replaceValue)
//参数：searchValue:需要替换的值    replaceValue:用来替换的值
</code></pre>
</li>
</ul>
<h2 id="-">基本包装类型</h2>
<blockquote>
<p><strong>简单数据类型是没有方法的</strong>。为了方便操作基本数据类型，JavaScript还提供了三个特殊的引用类型：String/Number/Boolean。</p>
</blockquote>
<p>基本包装类型：把基本类型包装成复杂类型。</p>
<pre><code class="lang-javascript">var str = “abc”;
var result = str.indexOf(“a”);
//发生了三件事情
1. 把简单类型转换成复杂类型：var s = new String(str);
2. 调用包装类型的indexOf方法：var result = s.indexOf(“a”);
3. 销毁刚刚创建的复杂类型（过河拆桥、卸磨杀驴）
</code></pre>

					<p><strong>更多内置对象及用法，请参考以下链接:</strong> <br />
						<a href="http://www.w3school.com.cn/jsref/index.asp">http://www.w3school.com.cn/jsref/index.asp</a><br />
						<a href="http://www.runoob.com/js/js-objects.html">http://www.runoob.com/js/js-objects.html</a>
					</p>
					
					
					<h1 id="bom">BOM</h1>
					<blockquote>
						<p>BOM（Browser Object Model）：浏览器对象模型，提供了一套操作浏览器功能的工具。</p>
					</blockquote>
					<p>BOM包含的内容很多，但是很多东西都不太常用。</p>
					<h2 id="window-">window对象</h2>
					<ol>
						<li>window对象是一个全局对象，也可以说是JavaScript中的顶级对象</li>
						<li>像document、alert()、console.log()这些都是window的属性，其实BOM中基本所有的属性和方法都是属性window的。</li>
						<li>所有定义在全局作用域中的变量、函数都会变成window对象的属性和方法</li>
						<li>window对象下的属性和方法调用的时候可以省略window</li>
					</ol>
					<p>重谈 this 关键字</p>
					<pre><code class="lang-javascript">1. this在普通函数中指的是window对象
2. this在方法中，指定的调用这个方法的对象（对象本身）
3. this在构造函数中，this指向新创建的对象
4. this在事件中，指向事件源，即触发事件的对象。
</code></pre>
					<h3 id="window-onload-">window.onload</h3>
					<blockquote>
						<p>window.onload事件会在窗体加载完成后执行，通常我们称之为入口函数。</p>
					</blockquote>
					<pre><code class="lang-javascript">window.onload = function(){
    //里面的代码会在窗体加载完成后执行。
    //窗体加载完成包括文档树的加载、还有图片、文件的加载完成。
}
</code></pre>
					<p>如果有图片加载，那么代码一定要写到window.onload里面，否则会出现图片没有加载完成，获取到的宽度和高度不对的情况。</p>
					<p>浏览器会对页面的加载做优化，在加载图片的时候，图片的引入会延迟。</p>
					<h3 id="window-open-window-close-">window.open与window.close</h3>
					<blockquote>
						<p>window.open() 打开一个窗口</p>
					</blockquote>
					<pre><code class="lang-javascript">//语法：window.open(url, [name], [features]);
//参数1：需要载入的url地址
//参数2：新窗口的名称
    //_self:在当前窗口打开
    //_blank:在新的窗口打开
//参数3：窗口的属性，指定窗口的大小
//返回值：会返回刚刚创建的那个窗口，用于关闭
//示例：
var newWin = window.open(&quot;http://www.baidu.com&quot;,&quot;_blank&quot;, &quot;width=300,height=300&quot;);
</code></pre>
					<blockquote>
						<p>window.close 关闭窗口</p>
					</blockquote>
					<pre><code class="lang-javascript">newWin.close()；//newWin是刚刚创建的那个窗口
window.close();//把当前窗口给关闭了
</code></pre>

					<h2 id="location-">location对象</h2>
					<blockquote>
						<p>location对象也是window的一个属性，location其实对应的就是浏览器中的地址栏。</p>
					</blockquote>
					<h3 id="-">常用属性和方法</h3>
					<blockquote>
						<p>location.href:控制地址栏中的地址</p>
					</blockquote>
					<pre><code class="lang-javascript">location.href = “http://www.baidu.com”;//让页面跳转到百度首页
</code></pre>
					<blockquote>
						<p>location.reload()：让页面重新加载</p>
					</blockquote>
					<pre><code class="lang-javascript">location.reload(true);//强制刷新，相当于ctrl+F5
location.reload(false);//刷新，相当于F5
</code></pre>
					<blockquote>
						<p>location的其他属性</p>
					</blockquote>
					<pre><code class="lang-javascript">console.log(window.location.hash);//哈希值 其实就是锚点
console.log(window.location.host);//服务器 服务器名+端口号
console.log(window.location.hostname);//服务器名
console.log(window.location.pathname);//路径名
console.log(window.location.port);//端口
console.log(window.location.protocol);//协议
console.log(window.location.search);//参数
</code></pre>
					<h2 id="-">其他对象</h2>
					<blockquote>
						<p>window.navigator的一些属性可以获取客户端的一些信息</p>
					</blockquote>
					<pre><code class="lang-javascript">//navigator.userAgent：浏览器版本
</code></pre>
					<blockquote>
						<p>history对象表示页面的历史</p>
					</blockquote>
					<pre><code class="lang-javascript">//后退：
history.back();
history.go(-1);
//前进：
history.forward();
history.go(1);
</code></pre>
					<blockquote>
						<p>screen对象</p>
					</blockquote>
					<pre><code class="lang-javascript">console.log(screen.width);//屏幕的宽度 
console.log(screen.height);//屏幕的高度
console.log(screen.availWidth);//浏览器可占用的宽度
console.log(screen.availHeight);//浏览器可占用的高度
</code></pre>
					<strong>更多对象方法请参考:</strong><a href="http://www.runoob.com/jsref/obj-navigator.html">http://www.runoob.com/jsref/obj-navigator.html</a>
					<h1 id="offset-">offset系列</h1>
					<blockquote>
						<p>offset系列用于用于获取元素自身的大小和位置，在网页特效中有广泛应用 offset系列主要有：offsetHeight、offsetWidth、offsetParent、offsetLeft、offsetTop
						</p>
					</blockquote>
					<h2 id="offsetheight-offsetwidth">offsetHeight与offsetWidth</h2>

					<p><strong>offsetHeight与offsetWidth</strong></p>
					<pre><code class="lang-javascript">1.    获取的是元素真实的高度和宽度
2.    获取到的是数值类型，方便计算
3.    offsetHeight与offsetWidth是只读属性，不能设置。
</code></pre>
					<img src="../images/offset.png" />

					<p><strong>style.height与style.width</strong></p>
					<pre><code class="lang-javascript">1.    只能获取行内样式
2.    获取到的是字符串类型，需要转换
</code></pre>
					<blockquote>
						<p><strong><em>结论</em></strong></p>
					</blockquote>
					<pre><code class="lang-javascript">1. 设置宽度高度使用style.width与style.height
2. 获取宽度和高度offsetWidth与offsetHeight
</code></pre>
					<h2 id="offsetparent">offsetParent</h2>
					<blockquote>
						<p>parentNode和offsetParent</p>
					</blockquote>
					<pre><code class="lang-javascript">1. parentNode始终是父元素
2. offsetParent是离当前元素最近的定位元素(absolute、relative)，如果没有，那就找body
</code></pre>
					<h2 id="offsetleft-offsettop">offsetLeft与offsetTop</h2>
					<blockquote>
						<p>offsetLeft: 自身左侧到offsetParent左侧的距离：left + margin-left <br /> offsetTop:自身顶部到offsetParent顶部的距离 : top + margin-top</p>
						<p>offsetLeft与offsetTop</p>
						<pre><code class="lang-javascript">1.    元素自身与offsetParent真实的距离
2.    获取到的是数值类型，方便计算
3.    只读属性，只能获取，不能设置
</code></pre>
						<p>style.left与style.top</p>
					</blockquote>
					<pre><code class="lang-javascript">1.    只能获取行内样式
2.    获取到的是字符串，需要转换
3.    可以获取，也可以设置
</code></pre>
					<blockquote>
						<p><strong>结论</strong></p>
					</blockquote>
					<pre><code class="lang-javascript">获取操作：用offset系列
设置操作：用style.xxx进行设置。
</code></pre>
					
					<h1>requestAnimationFrame</h1>
					<blockquote>
						<p>与setTimeout和setInterval不同，requestAnimationFrame不需要设置时间间隔，接下来介绍一下html5中新增的定时器。　requestAnimationFrame采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果</p>
					</blockquote>
					<h2>使用方法</h2>
					<p>requestAnimationFrame的用法与settimeout很相似，只是不需要设置时间间隔而已。requestAnimationFrame使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。它返回一个整数，表示定时器的编号，这个值可以传递给cancelAnimationFrame用于取消这个函数的执行</p>
					<pre><code>requestID = requestAnimationFrame(callback); 
//控制台输出1和0
var timer = requestAnimationFrame(function(){
    console.log(0);
}); 
console.log(timer);//1
//cancelAnimationFrame方法用于取消定时器
//控制台什么都不输出
var timer = requestAnimationFrame(function(){
    console.log(0);
}); 
cancelAnimationFrame(timer);
//也可以直接使用返回值进行取消
var timer = requestAnimationFrame(function(){
    console.log(0);
}); 
cancelAnimationFrame(1);
					</code></pre>
					<p><strong>更多资料:</strong><br />
					<a href="http://www.cnblogs.com/xiaohuochai/p/5777186.html">http://www.cnblogs.com/xiaohuochai/p/5777186.html</a>	
					</p>
					<h1>Ajax基础</h1>
					<blockquote>
						<p>AJAX(Asynchronous JavaScript and XML)（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。</p>
					</blockquote>
					<img src="../images/1.jpg" />
					<h2>XML和HTML的区别</h2>
					<h3>XML</h3>
					<blockquote>
						<p>
							可扩展标记语言，可对文档和数据进行结构化处理<br /> 它是用来传输数据，焦点是数据的内容

						</p>
					</blockquote>
					<h3>HTML</h3>
					<blockquote>
						<p>超文本标记语言<br /> 它是用来显示数据，焦点是数据的外观
						</p>
					</blockquote>
					<h2>Ajax工作原理</h2>
					<blockqupte>
						<p>所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。 XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
					</blockqupte>
					<p>下面来具体的说一下客户端使用ajax的步骤</p>
					<p><strong>第一步：创建XMLHttpRequest对象，用来和服务器交换数据。
</strong></p>
					<pre><code>var xhr=new XMLHttpRequest()
</code></pre>
					<p><strong>第二步：使用XMLHttpRequest对象的open和send方法发送请求。
</strong></p>
					<blockquote>
						<p>如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：</p>
					</blockquote>
					<pre><code>xhr.open("GET","ajax_info.txt",true);
xhr.send();
</code></pre>
					<table class="tb1">
						<thead>
							<tr>
								<td>方法</td>
								<td>描述</td>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>open(method,url,async)</td>
								<td>
									规定请求的类型、URL 以及是否异步处理请求。
									<ul>
										<li>method：请求的类型；GET 或 POST</li>
										<li>url：文件在服务器上的位置</li>
										<li>async：true（异步）或 false（同步）</li>
									</ul>
								</td>
							</tr>
							<tr>
								<td>send(string)</td>
								<td>
									将请求发送到服务器。
									<ul>
										<li>string：仅用于 POST 请求</li>
									</ul>
								</td>
							</tr>
						</tbody>
					</table>
					<pre><code>//使用post和get的区别
//get:GET 更简单也更快，并且在大部分情况下都能用。在使用get方法来请求的时候，要在url地址栏后面，进行传参
例如：xhr.open('get',url+'?'+key=value&key2=value2,true);
      xhr.send(null);
//post:以下情况写请使用post
	1、无法使用缓存文件（更新服务器上的文件或数据库）
	2、向服务器发送大量数据（POST 没有数据量限制）
	3、发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
例如：xhr.open('post',url,true)
      xhr.setRequestHeader('content-type','application/x-www-form-urlencoded');
      xhr.send('key=value&key2=value2')
</code></pre>
					<table class="tb1">
						<thead>
							<tr>
								<td>方法</td>
								<td>描述</td>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>setRequestHeader(header,value)</td>
								<td>
									向请求添加 HTTP 头。
									<ul>
										<li>header: 规定头的名称</li>
										<li>value: 规定头的值</li>
									</ul>
								</td>
							</tr>
						</tbody>
					</table>
					<p><strong>第三步：当服务器准备响应时将执行onreadystatechange函数
</strong></p>
					<blockquote>
						<p>当请求被发送到服务器时，我们需要执行一些基于响应的任务。 每当 readyState 改变时，就会触发 onreadystatechange 事件。 readyState 属性存有 XMLHttpRequest 的状态信息。 下面是 XMLHttpRequest 对象的三个重要的属性：</p>
					</blockquote>
					<table class="tb1">
						<thead>
							<tr>
								<td>属性</td>
								<td>描述</td>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>onreadystatechange</td>
								<td>存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。</td>
							</tr>
							<tr>
								<td>readyState</td>
								<td>存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。
									<ul>
										<li>0: 请求未初始化</li>
										<li>1: 服务器连接已建立</li>
										<li>2: 请求已接收</li>
										<li>3: 请求处理中</li>
										<li>4: 请求已完成，且响应已就绪</li>
									</ul>
								</td>
							</tr>
							<tr>
								<td>status</td>
								<td> 200: "OK"<br />404: 未找到页面</td>
							</tr>
						</tbody>
					</table>
					<blockquote>
						<p>在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。 当 readyState 等于 4 且状态为 200 时，表示响应已就绪：</p>
					</blockquote>
					<pre><code>xhr.onreadystatechange=function()
{
    if (xhr.readyState==4 && xhr.status==200)
    {
        document.getElementById("myDiv").innerHTML=xhr.responseText;
    }
}
</code></pre>
					<blockquote>
						<p>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。</p>
					</blockquote>
					<table class="tb">
						<thead>
							<tr>
								<td>属性</td>
								<td>描述</td>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>responseText</td>
								<td>获得字符串形式的响应数据。</td>
							</tr>
							<tr>
								<td>responseXML</td>
								<td>获得 XML 形式的响应数据。</td>
							</tr>
						</tbody>
					</table>
					<p><strong>第四步： 回调函数中使用responseText或responseXML属性获得服务器的响应，更改视图。
</strong></p>
					<p>如果来自服务器的响应是普通字符串，请使用 responseText 属性。
					</p>
					<pre><code>document.getElementById("myDiv").innerHTML=xhr.responseText;
</code></pre>
					<p>
						如果来自服务器的响应是 XML，请使用 responseXML 属性：
					</p>
					<pre><code>document.getElementById("myDiv").innerHTML=xhr.responseXML;
</code></pre>
					<p>如果来自服务器的相应是JSON格式的,就将JSON字符串转换成js对象</p>
					<pre><code>document.getElementById("myDiv").innerHTML=JSON.parse( xhr.responseText);
</code></pre>

					<p><strong>使用回调函数</strong></p>
					<blockquote>
						<p>回调函数是一种以参数形式传递给另一个函数的函数。 如果您的网站上存在多个 AJAX 任务，那么您应该为创建 XMLHttpRequest 对象编写一个标准的函数，并为每个 AJAX 任务调用该函数。 该函数调用应该包含 URL 以及发生 onreadystatechange 事件时执行的任务（每次调用可能不尽相同）：</p>
					</blockquote>
					<pre><code>function myFunction()
{
    loadXMLDoc("/try/ajax/ajax_info.txt",function()
    {
        if (xhr.readyState==4 && xhr.status==200)
        {
            document.getElementById("myDiv").innerHTML=xhr.responseText;
        }
    });
}
</code></pre>
					<p><strong>更多资料请参考:</strong><br />
						<a href="http://www.runoob.com/ajax/ajax-examples.html">http://www.runoob.com/ajax/ajax-examples.html</a>
						<br />
						<a href="http://www.w3school.com.cn/ajax/index.asp">http://www.w3school.com.cn/ajax/index.asp</a>
					</p>
					<h1>同步和异步</h1>
					<h2>实例</h2>
					<pre><code>&lt;script type='text/javascript'&gt;
    console.log('1');
    setTimeout(function(){
	    console.log('2');
    },1000);
    console.log('3')
&lt;script&gt;</code></pre>
					<h2>概念</h2>
					<ul>
						<li>操作分为：发出调用和得到结果两步。
						</li>
						<li>出调用，立即得到结果是同步。
						</li>
						<li>发出调用，但无法立即得到结果，需要额外操作才能得到预期结果为异步。
						</li>
						<li>同步就是调用后一直等待，直到返回结果。
						</li>
						<li>异步则是调用后，不能直接拿到结果，通过一系列手段才能最终拿到结果。（调用之后，拿到结果中间的时间可介入其它任务）
						</li>
					</ul>
					<h1>javascript单线程</h1>
					<h2>概述</h2>
					<blockquote>
						<p>在浏览器的一个页面内，该页面的JS程序只有一个线程。<br /> 因此，程序执行顺序为从上到下，同一时间内只有一段代码被执行。

						</p>
					</blockquote>
					<h2>设计原因</h2>
					<blockquote>
						<p>早期网页内容简单，单线程足以应付。<br /> 若以多线程操作DOM，一个线程要求删除该DOM，另一个要求修改DOM。这样的情况下，增加了程序设计复杂度。

						</p>
					</blockquote>
					<h2>浏览器</h2>
					<blockquote>
						<p>浏览器内核是多线程的。I/O操作、定时器和事件监听都由其它线程来完成的。<br /> 一个浏览器至少实现了三个线程：
							<br /> 1、JavaScript引擎线程
							<br /> 2、GUI渲染线程
							<br /> 3、浏览器事件触发线程

						</p>
					</blockquote>
					<img src="../images/15.png" alt="" />
					<h1>事件队列</h1>
					<h2>概述</h2>
					<blockquote>
						<p>单线程意味着，所有任务需要排队，顺序进行。<br /> 但是，当某个任务耗时较长时（如等待IO设备、Ajax操作从网络读取数据等），后面的任务将被阻塞。因此，JavaScript设计者在这种情况下，设计了事件队列，提供了异步操作。

						</p>
					</blockquote>
					<img src="../images/14.png" />
					<h1 id="-">递归函数和回调函数</h1>
<blockquote>
<p>递归函数：自己直接或者间接调用自己的函数，递归函数一定要留有出口，不然就是死循环了</p>
</blockquote>
<pre><code class="lang-javascript">1. 求1-100所有数的和

2. 斐波那契数列
</code></pre>
<blockquote>
<p>回调函数：把函数当成参数来使用，那么这个函数就叫回调函数。</p>
</blockquote>
<h1 id="arguments-">arguments对象</h1>
<blockquote>
<p>JavaScript中，arguments对象是比较特别的一个对象，实际上是当前函数的一个内置属性。也就是说所有函数都内置了一个arguments对象，arguments对象中存储了传递的所有的实参。arguments是一个伪数组，因此及可以进行遍历</p>
</blockquote>
<pre><code class="lang-javascript">//1. 求任意个数的最大值
//2. 求任意个数的和
</code></pre>
<h1 id="json-">json对象</h1>
<blockquote>
<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，采用完全独立于语言的文本格式，是理想的数据交换格式。同时，JSON是 JavaScript 原生格式，这意味着在 JavaScript 中处理 JSON数据跟处理对象是一样的。</p>
</blockquote>
<p>JSON的属性必须用双引号引号引起来，对象字面量可以省略</p>
<pre><code class="lang-javascript">//对于js对象来说，属性名的双引号是可以省略的。
var obj = {
  name:&quot;zs&quot;,
  age:18,
  sex:&quot;男&quot;
}

//json对象的属性名必须使用双引号括起来
var obj = {
  &quot;name&quot;:&quot;zs&quot;,
  &quot;age&quot;:18,
  &quot;sex&quot;:&quot;男&quot;
}

//在js中，其实就可以把json当成javascript的对象，因此操作是一样。
</code></pre>
					<h1>Javascript作用域</h1>
					<blockquote>
						<p><strong>定义</strong></p>
						<ul>
							<li>作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。
							</li>
							<li>在JavaScript中，变量的作用域有全局作用域和局部作用域两种</li>
						</ul>
					</blockquote>
					<h2>全局作用域（Global Scope）</h2>
					<blockquote>
						<ul>
							<li>在代码中任何地方，都能访问到的对象拥有全局作用域</li>
							<li>最外层函数和在最外层函数外面定义的变量拥有全局作用域</li>
							<li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li>
							<li>所有window对象的属性拥有全局作用域</li>
						</ul>
					</blockquote>
					<h2>局部作用域（Local Scope）</h2>
					<blockquote>
						<p>和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所有在一些地方也会看到有人把这种作用域称为函数作用域
						</p>
					</blockquote>
					<h2>JavaScript作用域链（Scope Chain）</h2>
					<blockquote>
						<p>在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。
						</p>
					</blockquote>
					<blockquote>
						<strong>相关参考资料：<br />
	<a href="http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html
">http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html
</a><br />
<a href="http://www.cnblogs.com/silentjesse/p/4024536.html
">http://www.cnblogs.com/silentjesse/p/4024536.html
</a><br />
<a href="http://www.cnblogs.com/syfwhu/p/4839562.html
">http://www.cnblogs.com/syfwhu/p/4839562.html
</a>
	</strong>
					</blockquote>
					<h1>Javascript闭包</h1>
					<blockquote>
						<p>各种专业文献上的"闭包"（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
						</p>
					</blockquote>
					<p>要理解闭包，首先必须理解Javascript特殊的变量作用域。<br /> 变量的作用域无非就是两种：全局变量和局部变量。
						<br /> Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。
					</p>
					<p><strong>下面来看一下闭包的实例</strong></p>
					<pre><code>function f1(){
    var n=999;
    nAdd=function(){n+=1}
    function f2(){
　　　　　　alert(n);
　　　　}
　　　　return f2;
　　}
　　var result=f1();
　　result(); // 999
　　nAdd();
　　result(); // 1000
  //result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。
</code></pre>
					<p><strong>更多资料请参考:</strong>
						<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html</a>
					</p>
					<h1>Javascript原型、原型链</h1>
					<h2>什么是原型?</h2>
					<blockquote>
						<p>在JavaScript中，原型也是一个对象，通过原型可以实现对象的属性继承，JavaScript的对象中都包含了一个”[[Prototype]]”内部属性，这个属性所对应的就是该对象的原型。<br /> 每个函数被创建的时候都会有一个prototye属性，这个属性会指向函数的原型对象。默认情况下每个原型对象又都会获取一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针。
						</p>
					</blockquote>
					<p>
						<srtong>原型图</srtong>
					</p>
					<img src="../images/9.png" alt="原型图" />
					<p><strong>参考资料:</strong><br />
						<a href="http://www.cnblogs.com/shuiyi/p/5305435.html">http://www.cnblogs.com/shuiyi/p/5305435.html</a><br />
						<a href="http://www.cnblogs.com/jizhongjing/p/5312987.html">http://www.cnblogs.com/jizhongjing/p/5312987.html</a>
					</p>
					<h2>原型链的概念</h2>
					<blockquote>
						<p>因为每个对象和原型都有原型，对象的原型指向原型对象， 而父的原型又指向父的父，这种原型层层连接起来的就构成了原型链。
						</p>
					</blockquote>
					<p><strong>参考资料：</strong><br />
						<a href="http://www.jb51.net/article/80109.htm">http://www.jb51.net/article/80109.htm</a>
					</p>
					<h2>Javascript继承</h2>
					<blockquote>
						<p>JS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。那么如何在JS中实现继承呢？</p>
					</blockquote>
					<table>
						<thead>
							<tr>
								<td>继承方法</td>
								<td>特点</td>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>原型链继承</td>
								<td>
									为父类实例添加新特性，作为子类实例返回
								</td>
							</tr>
							<tr>
								<td>实例继承</td>
								<td>
									1、非常纯粹的继承关系，实例是子类的实例，也是父类的实例<br /> 2、父类新增原型方法/原型属性，子类都能访问到
									<br /> 3、简单，易于实现
								</td>
							</tr>
							<tr>
								<td>构造函数继承</td>
								<td>
									使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）
								</td>
							</tr>
						</tbody>
					</table>
					<p><strong>参考资料:</strong><br />
						<a href="http://www.cnblogs.com/humin/p/4556820.html">http://www.cnblogs.com/humin/p/4556820.html</a><br />
						<a href="http://www.cnblogs.com/ayqy/p/4471638.html">http://www.cnblogs.com/ayqy/p/4471638.html</a>
					</p>
					<h1>复习小结</h1>
					<h2>总结</h2>
					<blockquote>
						<p>通过js进阶的学习，我们了解了javascript的更多特性和他的扩展，下面我们来总结一下讲了哪些内容</p>
						<ul class="space">
							<li>1、javascript有很多内置的对象，可以帮助我们更容易的开发</li>
							<li>2、了解了DOM的许多特性，以及操作DOM的方法和事件</li>
							<li>3、学习了什么是BOM，以及一些BOM对象的属性和方法</li>
							<li>4、offset系列，可以用来获取和设置元素的宽高</li>
							<li>5、事件对象，更通透的理解了js本身</li>
							<li>6、html5中新增的定时器requestAnimationFrame</li>
							<li>7、ajax技术，方便更新页面</li>
							<li>8、一些js扩展学习</li>
						</ul>
						<strong>更多学习资料请参考:</strong><br />
						<a href="http://www.runoob.com/js/js-tutorial.html">http://www.runoob.com/js/js-tutorial.html</a> <br />
						<a href="http://www.w3school.com.cn/js/">http://www.w3school.com.cn/js/</a>
					</blockquote>
					<h2>FAQ</h2>
					<p>
						<strong>1、当页面上的控件超过一定数量时该怎么办?</strong>
						<p>当页面上的控件超过一定数量时，应避免在循环里或多次使用document.getElementById(controlId)，特别在load页面时
       如果用过多的这种语句会浪费大量的时间在遍历页面控件上。</p>
					</p>
					<p>
						<strong>2、当使用checked属性的时候有什么注意点?</strong>
						<p>当使用checked属性的时候，由于<code>checked</code>的值是布尔类型的，只有true或者false，因此只要在标签中有
						checked字样，都表示默认打钩，只有<code>checked</code>字样不在标签中出现,才算默认不打钩。</p>
					</p>
					<p>	
						<strong>3、document.write可以用来生成新的节点，可以经常使用吗？</strong>
						<p>当使用document.write来生成新的节点的时候，因为document.write的本意就是在文档流上写入内容。
							如果页面没加载完成，文档流还是开着的，document.write直接在这个文档流上写东西 <br />
					如果页面加载完成了，还是用document.write写东西，会重新开启一个新的文档流，往新的文档流上写东西，旧的文档流就被新的文档流覆盖了。因此不推荐使用。</p></p>			
					</p>
					<p>
						<strong>4、json和jsonp的特点有哪些？</strong>
						<p>在前端开发过程中，有时候当后台没有给我们调数据接口的时候，不能查看页面功能到底有没有实现，因此要学会做假数据，通常做假数据的格式会使用json格式。<br />
						<strong>查看以下链接来了解一下什么是jsonp,以及json的一些特点:</strong> <br />
						<a href="http://www.runoob.com/json/json-tutorial.html">http://www.runoob.com/json/json-tutorial.html</a><br />
						<a href="http://www.w3school.com.cn/json/">http://www.w3school.com.cn/json/</a></p>
					</p>
					<p>
						<strong>5、有什么好的跨域的方法？</strong>
						<p>在使用ajax请求数据的时候，由于域名、端口、级别的不同，会出现跨域的问题，处理跨域有很多种办法，前端最常用的是通过jsonp来跨域<br />
						<strong>查看以下链接来了解什么是jsonp，以及jsonp的使用原理:</strong><br />
						<a href="http://blog.csdn.net/u011700203/article/details/46532455">http://blog.csdn.net/u011700203/article/details/46532455</a><br />
						<a href="http://www.runoob.com/json/json-jsonp.html">http://www.runoob.com/json/json-jsonp.html</a></p>
					</p>
					<p>
						<strong>6、清楚缓存的方法有哪些？</strong>
						<p>浏览器缓存，有时候我们需要他，因为他可以提高网站性能和浏览器速度，提高网站性能。但是有时候我们又不得不清除缓存，因为缓存可能误事，出现一些错误的数据。<br />
						<strong>查看以下链接了解浏览器清楚缓存的几种方式: </strong><br />
						<a href="http://www.haorooms.com/post/js_llq_hc">http://www.haorooms.com/post/js_llq_hc</a></p>
					</p>
					<p>
						<strong>7、在客户端向服务端请求数据的时候,会返回状态码，你了解哪些状态码？</strong>
						<p>在客户端向服务端请求数据的时候，会遇到各种各样的问题，当有情况发生的时候，服务器端会返回一个状态码给客户端，来通知请求数据是否成功，如果不成功，那么是遇到了什么问题
						每种状态都有一个号码来表示。
						<pre><code>//常见的几种状态码
200 //OK请求成功，请求所希望的响应头或数据体将随此响应返回。
404 //Not Found，请求失败，请求所希望得到的资源未被在服务器上发现。
503 //Service Unavailable由于临时的服务器维护或过载，服务器当前无法处理请求。</code></pre>
						<strong>了解更多状态码，请参考以下链接:</strong><br />
						<a href="http://www.cnblogs.com/-5012/p/5630598.html">http://www.cnblogs.com/-5012/p/5630598.html</a></p>
					</p>
					<h2>练习题</h2>
					<blockquote>
						<p>选择题</p>
						<div class="one">
							<p><strong>1、以下DOM操作方法中哪个可以返回带有指定ID的元素?</strong></p>
							<p>A getElementById()&nbsp;&nbsp;B getElementsByTagName()&nbsp;&nbsp;C getElementsByClassName()</p>
						</div>
						<div class="two">
							<p><strong>2、以下哪个方法可以删除子节点?</strong></p>
							<p>A appendChild()&nbsp;&nbsp;B replaceChild()&nbsp;&nbsp;C removeChild()</p>
						</div>
						<div class="three">
							<p><strong>3、以下哪个属性是布尔类型的属性?</strong></p>
							<p>A value&nbsp;&nbsp;B title&nbsp;&nbsp;C disabled</p>
						</div>
						<div class="four">
							<p><strong>4、foo对象有att属性，那么获取att属性的值，以下哪个是正确的?</strong></p>
							<p>A foo(“att”)&nbsp;&nbsp;B foo[“att”] &nbsp;&nbsp;C foo{“att”} </p>
						</div>
						<div class="five">
							<p><strong>5、以下哪个方法可以找到下一个兄弟节点?</strong></p>
							<p>A nextElementSibling&nbsp;&nbsp;B nextSibling &nbsp;&nbsp;C previousSibling </p>
						</div>
						<div class="six">
							<p><strong>6、以下哪个是鼠标离开时触发的事件?</strong></p>
							<p>A onmouseout &nbsp;&nbsp;B onmouseup &nbsp;&nbsp;C onmouseover </p>
						</div>
						<p>简答题</p>
						<div class="one">
							<p><strong>1、设置元素的宽高用什么方法?</strong></p>
						</div>
						<div class="two">
							<p><strong>2、获取元素的宽高用什么方法?</strong></p>
						</div>
						<div class="three">
							<p><strong>3、对于IE6、7、8来说，如何获取事件对象？</strong></p>
						</div>
						<div class="four">
							<p><strong>4、请简单的描述一下screenX、clientX、pageX这三者之间的区别？</strong></p>
						</div>
						<div class="five">
							<p><strong>5、请说出注册事件的两种方式</strong></p>
						</div>
						<div class="six">
							<p><strong>6、请简单的说出ajax的原理</strong></p>
						</div>
					</blockquote>
					<h2>习题讲解</h2>
					<blockquote>
						<p>选择题</p>
						<div class="one">
							<p>1、答案:A</p>
						</div>
						<div class="two">
							<p>2、答案:C</p>
						</div>
						<div class="three">
							<p>3、答案:C</p>
						</div>
						<div class="four">
							<p>4、答案:B</p>
						</div>
						<div class="five">
							<p>5、答案:B</p>
						</div>
						<div class="six">
							<p>6、答案:A</p>
						</div>
						<p>简答题</p>
						<div class="one">
							<p><strong>1、答案解析：</strong><br />设置宽度高度使用style.width与style.height</p>
						</div>
						<div class="two">
							<p><strong>2、答案解析：</strong><br />获取宽度和高度请使用offsetWidth与offsetHeight</p>
						</div>
						<div class="three">
							<p><strong>3、答案解析:</strong></p>
							<pre><code>btn.onclick = function(){
    //IE6、7、8通过window.event获取事件对象
    var event = window.event;
    console.log(event);
}</code></pre>
						</div>
						<div class="four">
							<p><strong>4、答案解析:</strong></p>
							<p>screenX与screenY：光标相对于屏幕左上角的水平位置与垂直位置。<br />
clientX与clientY：光标相对于可视区左上角的水平位置和垂直位置。<br />
pageX与pageY：光标相对于网页（文档document）左上角的水平位置与垂直位置（推荐使用）</p>
						</div>
						<div class="five">
							<p><strong>5、答案解析</strong></p>
							<p>1、on+事件名称 <br />
								2、addEventListener(type, func, useCapture)与removeEventListener(type, func, useCapture) <br />
								第一个参数:事件的类型 <br />
								第二个参数:函数，监听者，每次点击，这个函数就执行 <br />
								第三个参数:false
							</p>
						</div>
						<div class="six">
							<p><strong>6、答案解析</strong></p>
							<p>Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发送异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。
XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。
							</p>
						</div>
					</blockquote>
				</article>
				
			</div>
			<!--返回首页按钮-->
			<input class="btn" type="button" name="" id="" value="返回首页" />
			<!--跳转到下一章节-->
			<input class="btn1" type="button" name="" id="" value="下一章节" />
			<!-- 返回顶部按钮 -->
				<div class="backTop"></div>
		</div>
	</body>

</html>
<script type="text/javascript" src="../lib/toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="../lib/toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="../lib/toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="../lib/toc_conf.js"></script>
<script type="text/javascript" src="../js/common.js"></script>
<script>
	//下一章节
	$('.btn1').click(function(){
		location.href='./exercise4.html';
	})
</script>